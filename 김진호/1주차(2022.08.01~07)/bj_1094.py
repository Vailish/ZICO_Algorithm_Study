# 문제 순서 그대로 작성
want = int(input())
now = [64]
while 1:
    now[-1] = now[-1] / 2
    if sum(now) < want:
        now.append(now[-1])
    elif sum(now) == want:
        print(len(now))
        break

# 마지막 자리(제일 짧은 막대기)를 반으로 자른다. 모든 막대기를 더해 원하는 막대기보다 작다면 자른막대기를 하나 추가하고
# 만약 원하는막대기를 만들수있다면 현재 존재하는 막대기 수를 len함수로 확인하여 출력한다.

'''
단순정답

print(bin(int(input())).count('1'))

지민의 행동을 반복하는것은 이진법 형태로 전환하는 행동과 같다.
38 = 100110 ==> 막대기 3개
따라서 해당 수를 이진법으로 변환후 1의 개수만 세는것과 같은 행동이다.
'''

## 풀이간 특이사항

## 문제를 보고 이진법으로 만드는 형태와 같다는 생각을해서 아래 코드를 만들고, 이후 위쪽 순서에따라 작성해보았다.
## 해당 문제의 핵심을 파악해서 간단하게 만드는것이 좋지만, 복잡한 문제에서 이것이 쉽기 않기때문에
## 위 해결방식같이도 생각해봐야할것같다.
